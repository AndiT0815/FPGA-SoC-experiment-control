# labscript_FPGA-SoC_device
python code to implement FPGA-SoC board with labscript-suite

## The FPGA-SoC board

The FPGA-SoC (system-on-a-chip) board is used as a low-cost experimental control hardware for controlling cold and ultracold atoms experiments. It is designed to work together with existing hardware placed in a 19" rack and replaces the outdated DIO64 board from Viewpoint Systems. In each sub-rack several plug-in modules can be inserted, like digital or analog outputs which are programmed via a ribbon "bus" cable on the backplane of the sub-rack. A custom [buffer card](/FPGA-buffer-card) was designed to buffer and level-shift the signal from the FPGA-SoC board voltage lever (3.3V) to that of the rack (5V). It additionally hosts clock input and output buffers for an external clock reference and buffers for external I/O which allows to synchronize several boards and as start/stop trigger. The FPGA-SoC board is connected with Arduino style headers to the buffer card and they are together inserted into one slot of the sub-rack and drive the backplane bus. The idea was that the new buffer card replaces the old opto-coupler card which is now not needed anymore. The FPGA-SoC board is the commercial low-cost board Cora-Z7 from Digilent. It has a FPGA-SoC chip from Xilinx (Zynq-7007S) consisting of a FPGA part and a CPU. The board hosts Gigabit Ethernet, USB (device and host) ports and plenty of external pins in an extended Arduino style layout. On the CPU part a simple embedded Linux operating system (Petalinux 2020 with linux kernel 5.4) is running which faciliates proptyping and tests where one can execute custom application generated for example with C/C++ or Python. The second section of the chip is the FPGA (field-programmable gate array) part which contains the custom hardware design (programmed in Verilog) which generates the signals which communicate with the hardware devices in the sub-rack via the backplane bus. 

Each FPGA-SoC board can drive up to two sub-racks when they are not too far apart (few meter). For larger separations two FPGA-SoC boards are recommended.

The channels (plug-in modules into sub-racks) are distinguished with a 7-bit address which must be unique for each sub-rack. The device-dependent data word is 16-bits long which allows to address 16 digital channels or to set the voltage of one 16-bit DAC. The FPGA-SoC puts the address and data word on the bus at the programmed time and after about 300ns (for 1MHz bus update rate; this can be configured) another bit on the bus (called 'strobe') goes high and after about 300ns goes low. The rising edge of the strobe triggers the addressed channel to update its output according to the programmed data word. The delay (usually referred as "setup time") ensures that all data and address bits are settled. Since the strobe signal acts like a clock but is changing state only when needed (different to a real clock), it is called 'pseudoclock' by labscript.

## Implementation as a labscript-suite device

The present software implements the FPGA-SoC board as a labscript device. Labscript-suite (https://docs.labscriptsuite.org/) is a free software package written in Python which allows to control ion, cold- or ultracold atoms experiments. It consists of 'runmanager' which generates the experimental sequence data, 'runviewer' which allows to visualize the data like oscilloscope traces and 'BLACS' which interacts with the hardware. The additional program 'Lyse' allows to gather data (like images) and analyze it. The experimental sequence, i.e. the list of actions as a function of time, is saved as Python script file [see example FPGA_test.py](/labscript-suite/userlib/labscriptlib/FPGA_test/FPGA_test.py) which the user edits. A separate file [connection_table.py](/labscript-suite/userlib/labscriptlib/FPGA_test/connection_table.py) is used to declare the hardware and needs to be imported into each experiment script.

The FPGA-SoC board is implemented in [FPGA_device.py](/labscript-suite/userlib/user_devices/FPGA_device.py) as a "pseudoclock device" (FPGA_board). The plugin-modules (having several channels) are implemented as "intermediate device" (DigitalChannels and AnalogChannels) and the individual channels are standard labscript digital and analog outputs (DigitalOut and AnalogOut).

Each FPGA board can drive up to 2 sub-racks where the second sub-rack shares the same address and data space but individual pseudoclock ('strobe') signals are generated such that only one or the other or both sub-racks are addressed. The timing of the two pseudoclocks can be adjusted individually allowing also to compensate for run-time delays on the different cable lengths.

Several FPGA boards can be declared in the connection table. One of the board must be defined as the primary board (in labscript termed as "master pseudoclock") for which the "trigger_device" entry must be None and for all other boards, called secondary boards, "trigger_device" is set to the name of the primary board. In order to synchronize the boards in time the primary board provides its internal clock on the "clock out" port which needs to be connected with a coaxial cable (and maybe splitter) to the "clock in" of the secondary boards. Alternatively, a shared external clock can be be used instead for all boards. Additionally, the primary board provides a "trigger" (also called "sync out") signal at the start of the experiment which needs to be input to the secondary boards. All output and input signals can be configured by software, either in the connection table, the experimental script or in the BLACS GUI. For examples see [connection_table.py and FPGA_test.py files](/labscript-suite/userlib/labscriptlib/FPGA_test/).

## Steps to get started

1. install labscript-suite on your computer as described here: https://docs.labscriptsuite.org/en/stable/installation/
2. you have to edit the file /labscript-suite/labconfig/\<your computer name\>.ini: give for "apparatus_name" the name of your experiment. This defines in which folder in /labscript-suite/userlib/labscriptlib/ your connection table and experiment script are located. I usually set save_hg_info = False since I have not hg (Mercurial) installed.
3. copy into the folder /labscript-suite/userlib/user_devices: FPGA_device.py, register_classes.py and generic_conversion.py
4. copy into the folder /labscript-suite/userlib/labscriptlib/\<apparatus name\>: conncetion_table.py and FPGA_test.py
5. edit 'FPGA_test.py' and connection_table.py for your actual experimental setup. For example you want to give proper names to each of the channels.
6. to start runmanager and blacs on Windows you will most likely find some desctop shortcuts, on linux it depends how you installed: most likely you launch them from the terminal after activation of a virtual environment. I use instead Pycharm-community.
7. after you started BLACS it will ask you to compile the connection table. Just press the compile button and after the small window appeared and it hopefully successfully compiled click on restart BLACS. BLACS restarts but unfortunately, it will always give error messages ("Broken Pipe" on Ubuntu, something else on Windows) and you have to manually close all of the popup error windows and BLACS and restart it. After manual restart the errors are gone. I have not understood where these errors are coming from but I assume its a bug in labscript. 
8. now yo can lanuch runmanager (sometimes you have to restart it after BLACS recompile and restart error) and click on "Engage" to compile your experiment script. When you have enabled "Run shot(s)" the sucessful created hd5-file with the data is inserted into the "Filepath" table of experiments in BLACS.
9. in BLACS click on the "Pause" button when it is gray and the experiment should be executed. When you enable the "Repeat" button then all files in the table are executed in a loop until you push the "Repeat" button again. To get an idea of the execution of the boards click on the black square in the top-right corner of the board tab. This opens the terminal showing messages from the blacs worker talking with the board (and maybe with the other boards). This is helpful if something goes wrong. The Digital and Analog outputs buttons open the sections where you can set outputs manually. In the "FPGA board" section you can see the current setup of the board and you can temporarily do changes after you enabled "allow changes (caution!)" - this is for testing. The "get state" button prints the actual board state in the terminal window. The disconnect button disconnects the board. The "abort!" button I think does not do anything at the moment.

## notes regarding the 'pseudoclock'

The concept of the 'pseudoclock' has caused some confusion. As stated above, it is a phycical (digital) signal which acts like a clock but changes state only when needed, i.e. only when some device on the sub-rack has to read data from the bus and change state. Most labscript devices are either a pseudoclock device (like the Pulseblaster) or so-called intermediate device (like the National Instruments cards) which uses an external pseudoclock device for timing. The pseudoclock device can provide several pseudoclocks to clock devices at different rates and some of them have also a limited number of digital channels (called "direct outputs") for arbitrary use. The present implementation features both the "FPGA_board", as the pseudoclock device handling the timing, and two intermediate devices ("DigitalChannels" and "AnalogChannels"), handling the actual channel data. Time and channel data is not separated here and is uploaded on each FPGA board on a single data structure. This has historic reasons because this was the data expected by the Viewpoint Systems DIO card which the present FPGA board is supposed to replace.

However, the pseudoclock approach of separate time and channel data (and devices) would have two big advantages: 1. for each channel only the state changes need to be memorized and uploaded, and 2. the channels can run independently. Point 1 is important for long experiments with high data rates where probably for large spans of time not much is happening. In this case either an enormeous contiguous stream of data would need to be generated and uploaded when a contiguous clock would be employed (often referred to as "waveform mode") or for each state change of each channel the time would need to be saved together with the data, which complicates the design and requires more memory. One solution to reduce the memory requirement would be to save the time when any channel changes state and save the corresponding state of all channels regardless if the state changes or not. This is the approach used by the Viewpoint Vision DIO card which we are using in the FPGA_device here. This has the drawback that a single high-rate channel causes that all other channels which might do nothing have to be memorized as well. This is point 2 of the advantes of the pseudoclock approach, that channels with a high rate or channels with very different rates can be clocked with separate pseudoclocks and this way does not affect each other.



