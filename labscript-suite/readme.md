# labscript_FPGA-SoC_device
python code to implement FPGA-SoC board in labscript-suite

The FPGA-SoC board:
The board is used as a low-cost experimental control hardware for controlling cold and ultracold atoms experiments. It is designed to work together with existing hardware placed in a 19" rack and replaces the outdated DIO64 (probably also DIO128) boards from Viewpoint Systems. In each rack several plug-in modules can be inserted, like digital or analog outputs which are programmed via a ribbon cable "bus" on the backplane of the rack. A custom buffer card was designed to buffer and level-shift the signal from the FPGA-SoC board (3.3V) from the rack (5V) and which hosts clock input and output buffers for an external clock reference and additional buffers for external triggers and to synchronize several boards. The FPGA-SoC board is connected with the Arduino style headers to the buffer card which is directly inserted into the rack and connects to the backplane bus. The setup might be also compatible with similar racks used with other digital I/O cards like the ones from National Instruments. The board is a commercial low-cost board from Digilent Inc. called Cora-Z7. The board has a FPGA-SoC chip from Xilinx (Zynq-7010 or 7007S), Gigabit Ethernet, USB (device and host) ports and plenty of external pins in an extended Arduino style layout. On the FPGA-SoC (system-on-a-chip) a simple embedded Linux operating system (Petalinux 2020, kernel 5.4) is running on the CPU which faciliates proptyping and tests where one can execute custom application generated for example with C/C++ or Python. The second half of the chip is the FPGA (field-programmable gate array) part which contains custom hardware design (programmed in Verilog) which generates the signals which communicate with the hardware devices on the sub-rack bus. 

Each FPGA-SoC board can drive 2 racks but they should be nearby. This was implemented since the old DIO card was able to drive two racks. If the two racks are far (> 1m) apart consider to use two FPGA-SoC boards instead in order to have a tight timing.

The channels (or plug-in modules) are distinguished with a 7-bit address which must be unique for each sub-rack. The same addresses are allowed on different sub-racks since these are independent. The device-dependent data word is 16-bits long which allows to address 16 digital channels or one 16-bit DAC. The FPGA-SoC puts the address and data word on the bus at the programmed time and after about 300ns (for 1MHz bus update rate; this can be configured) another bit on the bus (called the 'pseudeclock' or 'strobe') goes high and after about 300ns goes low. This triggers the addressed channel to update the output.

Implementation as a labscript-suite device:
The present software implements the FPGA-SoC board as a labscript-suite device. Labscript-suite (https://docs.labscriptsuite.org/) is a free software package written in Python which allows to control ion, cold- or ultracold atoms experiments. It consists of 'runmanager' which generates the experimental sequence data, 'runviewer' which allows to visualize the data like oscilloscope traces and 'BLACS' which interacts with the hardware. The additional program 'Lyse' allows to gather data (like images) and analyze it. The experimental sequence, i.e. the list of actions as a function of time, is saved as an easy-to-read Python file (see example FPGA_test.py) which the user edits. A separate file "connection_table.py" is used to declare the hardware and needs to be imported into each experiment script.

The FPGA-SoC board is implemented in FPGA_device.py as a "pseudoclock device" (FPGA_board). The plugin-modules (having several channels) are implemented as "intermediate device" (DigitalChannels and AnalogChannels) and the individual channels are standard labscript digital and analog outputs (DigitalOut and AnalogOut).

Each FPGA board can drive up to 2 sub-racks where the second sub-rack shares the same address and data space but individual pseudoclock ('strobe') signals are generated such that only one or the other or both sub-racks are addressed. The timing of the two pseudoclocks can be adjusted individually allowing also to compensate for run-time delays on the different cable lengths.

Several FPGA boards can be declared in the connection table. One of the board must be defined as primary board (in labscript termed as "master pseudoclock") for which the "trigger_device" entry must be None and for all other boards, called secondary boards, "trigger_device" is set to the name of the primary board. In order to synchronize the boards in time the primary board provides its internal clock on the "clock out" port which needs to be connected with a coaxial cable (and maybe splitter) to the "clock in" of the secondary boards. Additionally, the primary board provides a "trigger" (also called "sync out") signal at the start of the experiment which needs to be input to the secondary boards. All output and input signals can be configured by software, either in the connection table, the experimental script or in the BLACS GUI. For examples see connection_table.py and FPGA_test.py files.

Steps to get started:
1. install labscript-suite on your computer as described here: https://docs.labscriptsuite.org/en/stable/installation/
2. into the folder labscript-suite/userlib/user_devices copy the three files: FPGA_device.py, register_classes.py and generic_conversion.py
3. into the folder labscript-suite/userlib/labscriptlib/\<experiment name\> copy conncetion_table.py and FPGA_test.py
4. edit 'FPGA_test.py' and connection_table.py for your experimental setup
5. on Windows you will most likely find some shortcuts on the desctop to start runmanager and blacs, in linux it depends how you installed: most likely you launch them from the terminal after activation of an virtual environment. I use for example Pycharm-community to edit and execute them.


