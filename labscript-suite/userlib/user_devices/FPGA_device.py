#####################################################################
# FPGA-SoC device by Andreas Trenkwalder
# created 6/4/2021 (adapted from RFBlaster.py) 
# works as PseudoClock and IntermediateDevice
#####################################################################

#import os
from labscript import PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice, DDS, DigitalOut, AnalogOut, set_passed_properties, LabscriptError, config
from labscript_devices import BLACS_tab, runviewer_parser
from labscript_utils.setup_logging import setup_logging
from sys import float_info

import numpy as np
from time import sleep
import struct
import h5py, labscript_utils.h5_lock

#default connection
PRIMARY_IP   = '192.168.1.11'
SECONDARY_IP = '192.168.1.12'
DEFAULT_PORT = '49701'
SOCK_TIMEOUT = 5.0                  # timeout for socket communication in seconds

#global settings
MAX_FPGA_RATE   = 10                        # maximum bus output rate of FPGA in MHz. 30MHz should be possible but not tested.
MAX_BUS_RATE    = 1                         # supported bus output rate in MHz for all of the devices. TODO: overwrite with argument for IM devices
MAX_CLOCKLINES  = 1                         # only 1 clockline is allowed
MAX_RACKS       = 2                         # 2 racks can share one clockline
MAX_SHOW        = 100                       # maximum number of samples untilrun which data is shown

#bus data structure
ADDR_SHIFT      = 16                        # first bit of address 
ADDR_MASK       = 0x7f                      # address mask (7bits, strobe is ignored since generated by FPGA)
ADDR_MASK_SH    = ADDR_MASK<<ADDR_SHIFT     # address mask shifted
DATA_MASK       = 0xffff                    # data field mask (16bits)
DATA_ADDR_MASK  = DATA_MASK|ADDR_MASK_SH    # combined data field + address mask (23bits)
MAX_ADDRESS     = ADDR_MASK                 # largest possible address
MAX_TIME        = 0xffff_ffff               # largest possible timestamp (32bits)
NOP_BIT         = 31                        # bit indicating no operation = no strobe generated
NOP_BIT_SH      = (1<<NOP_BIT)              # NOP bit shifted in place

#device types (used for ID)
TYPE_board      = 0
TYPE_DO         = 1
TYPE_AO         = 2 

#server commands (2 bytes: [command,size of data in bytes including command]) 
SERVER_ACK              = struct.pack('<2s', b'\xf0\x02')
SERVER_NACK             = struct.pack('<2s', b'\xf1\x02')
SERVER_RESET            = struct.pack('<2s', b'\xf2\x02')
SERVER_OPEN             = struct.pack('<2s', b'\x10\x02')
SERVER_CLOSE            = struct.pack('<2s', b'\x14\x02')
SERVER_CONFIG           = struct.pack('<2s', b'\x30\x1a')
SERVER_WRITE            = struct.pack('<2s', b'\x32\x06')
SERVER_START            = struct.pack('<2s', b'\x33\x06')
SERVER_STOP             = struct.pack('<2s', b'\x34\x02')
SERVER_STATUS           = struct.pack('<2s', b'\xf7\x02')       # polls actual status
SERVER_STATUS_RSP       = struct.pack('<2s', b'\xf7\x0e')
SERVER_STATUS_IRQ       = struct.pack('<2s', b'\xf8\x02')       # allows to wait for update/end instead of polling 
SERVER_STATUS_IRQ_RSP   = struct.pack('<2s', b'\xf8\x0e')
#TODO: SERVER_STATUS_FULL                                       # full status information could be displayed in console of device when a button is clicked

#return packed bytes to configure server (SERVER_CONFIG)
def to_config(
        cmd,            # in_out 16bit: must be SERVER_CONFIG
        clock_Hz,       # in_out 32bit: in: external clock frequency in Hz (unused if internal clock used), out: actual used clock frequency in Hz
        scan_Hz,        # in_out 32bit: in: requested scan rate in Hz, out: actual scan rate in Hz
        config,         # in_out 32bit: in: configuration bits for DIO24_IOCTL_SET_CONFIG, out: old configuration bits
        extrig,         # input  32bit: configuration bits for DIO24_IOCTL_SET_EXTRIG (not yet implemented)
        reps,           # input  32bit: number of repetitions. 0=infinite, 1=default.
        trans           # input  32bit: number of samples
        ):
    return struct.pack('<2s6I', cmd, clock_Hz, scan_Hz, config, extrig, reps, trans)

#returns unpacked bytes from server into server configuration data (SERVER_CONFIG). for data see to_config.
def from_config(bytes):
    #print('Andi unpack', bytes)
    return struct.unpack('<2s6I', bytes)

#return packed bytes with client_data32 structure
def to_client_data32(
        cmd,            # in_out 16bit: command
        data32          # in_out 32bit: data
        ):
    return struct.pack('<2sI', cmd, data32)

#returns unpacked bytes with client_data32 structure from server [cmd, data32]
def from_client_data32(bytes):
    return struct.unpack('<2sI', bytes)
    
#returns unpacked bytes with client_status structure from server:
# 16bit: command, must be SERVER_STATUS_RSP or SERVER_STATUS_IRQ_RSP
# 32bit: FPGA status register bits
# 32bit: board_time
# 32bit: board_samples
def from_client_status(bytes):
    return struct.unpack('<2s3I', bytes)

# FPGA control register bits
CTRL_RESET                  = 1<<0           # reset enabled (not settable by user)
CTRL_READY                  = 1<<1           # server ready (not settable by user)
CTRL_RUN                    = 1<<2           # run enabled (not settable by user)
CTRL_RESTART_EN             = 1<<4           # automatic restart
CTRL_AUTO_SYNC_EN           = 1<<5           # auto-sync enabled
CTRL_AUTO_SYNC_PRIM         = 1<<6           # auto-sync primary board = generate pulse & start timer , if false wait for pulse
CTRL_AUTO_SYNC_FET          = 1<<7           # auto-sync enable FET = reflect pulse
CTRL_BPS96                  = 1<<8           # data format 0=64bits/sample (default), 1=96bits/sample 
CTRL_BPS96_BRD              = 1<<9           # data+address selection if DIO_CTRL_BPS96=1: 0=2nd 32bit, 1=3rd 32bit (time=1st 32bit)
CTRL_EXT_CLK                = 1<<10          # 0/1=use internal/external clock
CTRL_IRQ_EN                 = 1<<20          # FPGA all irq's enabled
CTRL_IRQ_END_EN             = 1<<21          # FPGA end irq enabled
CTRL_IRQ_RESTART_EN         = 1<<22          # FPGA restart irq enabled
CTRL_IRQ_FREQ_EN            = 1<<23          # FPGA irq with DIO_IRQ_FREQ enabled
CTRL_IRQ_DATA_EN            = 1<<24          # FPGA irq with DIO_BIT_IRQ enabled
CTRL_TRG_START_EN           = 1<<28          # enable start trigger
CTRL_TRG_STOP_EN            = 1<<29          # enable stop trigger

# combined control bits
CONFIG_RUN_64               = CTRL_IRQ_EN|CTRL_IRQ_END_EN|CTRL_IRQ_FREQ_EN
CONFIG_RUN_RESTART_64       = CONFIG_RUN_64|CTRL_IRQ_RESTART_EN|CTRL_RESTART_EN
CONFIG_RUN_96               = CONFIG_RUN_64|CTRL_BPS96
CONFIG_RUN_RESTART_96       = CONFIG_RUN_RESTART_64|CTRL_BPS96

# FPGA status register bits
STATUS_RESET                = 1<<0           # reset active
STATUS_READY                = 1<<1           # ready state = first data received & not end
STATUS_RUN                  = 1<<2           # running state
STATUS_END                  = 1<<3           # end state = num_samples reached
STATUS_RESTART              = 1<<4           # restart toggle bit
STATUS_AUTO_SYNC            = 1<<5           # auto-sync active
STATUS_AS_TIMEOUT           = 1<<6           # auto-sync timeout
STATUS_PS_ACTIVE            = 1<<7           # phase shift active
STATUS_EXT_USED             = 1<<10          # 0/1=internal/external clock is used
STATUS_EXT_LOCKED           = 1<<11          # external clock is locked
STATUS_ERR_TX               = 1<<12          # error TX timeout loading of data
STATUS_ERR_RX               = 1<<13          # error RX not ready
STATUS_ERR_TIME             = 1<<14          # error timing
STATUS_ERR_LOCK             = 1<<15          # error lock lost
STATUS_ERR_TKEEP            = 1<<16          # error tkeep signal
STATUS_ERR_TKEEP2           = 1<<17          # error tkeep signal
STATUS_ERR_TKEEP3           = 1<<18          # error tkeep signal
STATUS_IRQ_FPGA_ERR         = 1<<20          # FPGA error irq
STATUS_IRQ_FPGA_END         = 1<<21          # FPGA end irq
STATUS_IRQ_FPGA_RESTART     = 1<<22          # FPGA restart irq
STATUS_IRQ_FPGA_FREQ        = 1<<23          # FPGA IRQ_FREQ
STATUS_IRQ_FPGA_DATA        = 1<<24          # FPGA IRQ_DATA
STATUS_TRG_START            = 1<<28          # start external trigger active
STATUS_TRG_STOP             = 1<<29          # stop external trigger active
STATUS_BTN_0                = 1<<30          # button 0
STATUS_BTN_1                = 1<<31          # button 1

# combined status bits
STATUS_ERROR                = STATUS_ERR_TX|STATUS_ERR_RX|STATUS_ERR_TIME|STATUS_ERR_LOCK|STATUS_ERR_TKEEP|STATUS_ERR_TKEEP2|STATUS_ERR_TKEEP3

# default configuration
CONFIG_CLOCK        = 50000000              # 50MHz, not used at the moment
CONFIG_SCAN         = 10000000              # 10MHz, requested sampling rate. overwritten by FPGA_board.bus_rate
CONFIG_CTRL         = CONFIG_RUN_96         # control bits
CONFIG_EXTRIG       = 0x00000000            # not used
CONFIG_REPS         = 1                     # repetitions, 0=infite, 1=default. needs restart bit in configuration if other than 1 (but not fully tested)
CONFIG_TRANS        = 0                     # number of samples but can be given later.

# stop options
STOP_NOW            = 0                     # abort any output
STOP_AT_END         = 1                     # stop at end of cycle (not implemented)

# PseudoClock
# accepts only ClockLine as childs
class FPGA_PseudoClock(Pseudoclock):
    def add_device(self, device):
        #print('Andi: FPGA_PseudoClock add device:', device.name)
        if isinstance(device, ClockLine):
            if len(self.child_devices) >= MAX_CLOCKLINES:
                raise LabscriptError("Connecting '%s' to '%s' failed because already maximum %i ClockLines connected"%(device.name, self.name, MAX_CLOCKLINES))
            Pseudoclock.add_device(self, device)
        else:
            raise LabscriptError('%s allows only ClockLine child but you have connected %s (class %s).'%(self.name, device.name, device.__class__))

def parse_num(num):
    "parse string into integer number. string can be prefixed with '0x' for hex number"
    #TODO: which exceptions can int() raise?
    if isinstance(num, str):
        if len(num) > 2:
            if (num[0]=='0') and (num[1]=='x'): # hex number
                return int(num[2:],16)
            else: return int(num)
        else: return int(num)
    else:
        return num # assume is already a number

#basic checking when adding new devices to one of the IntermediateDevice below
#returns decimal numbers [rack,address,channel] of device or raises LabscriptError on error
def check_device(device, allowed_type, max_channels, device_list, shared_address):
    #check device type
    if not isinstance(device, allowed_type):
        raise LabscriptError("device '%s', type %s must be of type %s" % (device.name, str(type(device)),str(device_typpe)))
    # rack is always given by parent device
    rack = device.parent_device.rack
    #get address or channel
    if shared_address: # get rack & address from parent. channel defines data bits.
        address = device.parent_device.address
        channel = parse_num(device.connection)
    else: # each channel has its own rack/address. channel not needed (maybe in GUI).
        address = parse_num(device.connection)
        channel = len(device_list)
    #check valid rack number
    if (rack<0) or (rack >= MAX_RACKS):
        LabscriptError("For device '%s' rack number %i given but only 0..%i allowed!"%(device.name, rack, MAX_RACKS-1))
    #check maximum number of channels
    if len(device_list) >= max_channels:
        raise LabscriptError("You tried to add device '%s' to '%s' but which has already %i channels." % (device.name, device.parent_device.name, max_channels))
    #check valid channel number
    if (channel<0) or (channel >= max_channels):
        raise LabscriptError("Device '%s' channel number %i must be 0..%i." % (device.name, channel, max_channels-1))
    #ensure rack/address/channel is unique in this ClockLine
    for IM in device.parent_device.parent_device.child_devices: # intermediate devices
        #print('Andi check IM',IM.name)
        for dev in IM.child_devices:
            if (dev.rack == rack) and (dev.address == address) and (dev.channel == channel):
                raise LabscriptError("device '%s' rack/address/channel %i/%i/%i is already used by '%s'" % (device.name, rack, address, channel, dev.name))
    #return [rack,address,channel] of new device
    return [rack,address,channel]
        
# IntermediateDevice with digital output channels
# channel numbers must be unique. all channels have the parent address (called 'connect' for consistency)
class DigitalChannels(IntermediateDevice):
    allowed_children = [DigitalOut]
    description = 'digital output device with several channels'
    clock_limit = MAX_BUS_RATE*2.0e6 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
    num_racks = 0 # set to maximum allowed number of racks given by FPGA_board

    def __init__(self, name, parent_device, connection, rack, max_channels, **kwargs):
        #init class but without parent_device otherwise raises error since needs to be ClockLine
        IntermediateDevice.__init__(self, name, None, **kwargs)
        #parent device must be FPGA_board. you should not connect it directly to clockline.
        if not isinstance(parent_device, FPGA_board):
            raise LabscriptError("Device '%s' parent class is '%s' but must be '%s'!" % (self.name, parent_device.__class__, FPGA_board))
        #self.clock_limit = parent_device.clock_limit
        self.num_racks = parent_device.num_racks
        self.max_channels = max_channels
        self.rack = rack
        self.address = parse_num(connection)
        if (self.rack < 0) or (self.rack >= self.num_racks):
            raise LabscriptError("For device '%s' rack number %i given but only 0..%i allowed!" % (self.name, self.rack, self.num_racks))
        if (self.address < 0) or (self.address > MAX_ADDRESS):
            raise LabscriptError("For device '%s' address %x given but only 0..%x allowed!" % (self.name, self.address, MAX_ADDRESS))
        #save address bits
        self.addr_bits = self.address<<ADDR_SHIFT
        #manually connect with parent_device._clockline
        self.parent_device = parent_device._clockline
        parent_device._clockline.add_device(self)

    def add_device(self, device):
        #print('Andi FPGA_Intermediatedevice: add device', device.name)
        #check if valid device, channel and if channel is already used
        #we use shared address from parent (DigitalChannels)
        device.rack, device.address, device.channel = check_device(device, DigitalOut, self.max_channels, self.child_devices, True)
        device.type = TYPE_DO
        #data bit for this channel
        device.ch_bit = 1<<device.channel
        IntermediateDevice.add_device(self, device)
        #save device address TODO: this should be in the connection property of device but how do I get it in DeviceTab?
        device.set_property('address', '%i/%i/%i'%(device.rack,device.address,device.channel), 'connection_table_properties')

    def get_data(self, times, data, changes):
        "combine data bits of digital channels"
        d = np.zeros(len(times),dtype=np.uint32)
        #combine all channels into data. there can be no time conflicts within channels.
        #dev.raw_output gives state 0 or 1
        for i,dev in enumerate(self.child_devices):
            #print('Andi combine DO',dev.name)
            d = d | (dev.raw_output * dev.ch_bit)
        #list of state changes
        chg = np.concatenate([[d[0]!=0],(np.array(d[1:]-d[0:-1])!=0)])
        #check conflicts with other devices
        if any(changes[:,self.rack] & chg):
            raise LabscriptError("device '%s' time conflict at time(s):\n%s" % (self.name, str(times[changes[:,self.rack] & chg])))
        #combine data
        data[:,self.rack+1] = data[:,self.rack+1] | ((d|self.addr_bits) & (chg*DATA_ADDR_MASK))
        #update changes
        changes[:,self.rack] = changes[:,self.rack] | chg

# IntermediateDevice with analog output channels
# channels have individual addresses (saved in 'connect').
class AnalogChannels(IntermediateDevice):
    allowed_children = [AnalogOut]
    description = 'analog output device with several channels'
    clock_limit = MAX_BUS_RATE*2.0e6 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
    num_racks = 0 # set to maximum allowed number of racks given by FPGA_board

    def __init__(self, name, parent_device, rack, max_channels, **kwargs):
        #init class but without parent_device otherwise raises error since needs to be ClockLine
        IntermediateDevice.__init__(self, name, None, **kwargs)
        #parent device must be FPGA_board. you should not connect it directly to clockline.
        if not isinstance(parent_device, FPGA_board):
            raise LabscriptError("Device '%s' parent class is '%s' but must be '%s'!" % (self.name, parent_device.__class__, FPGA_board))
        #self.clock_limit = parent_device.clock_limit
        self.num_racks = parent_device.num_racks
        self.rack = rack
        self.max_channels = max_channels
        if rack >= self.num_racks:
            raise LabscriptError("Device '%s' specified rack number %i is larger than allowed %i!" % (self.name, rack, self.num_racks-1))
        #manually connect with parent_device._clockline
        self.parent_device = parent_device._clockline
        parent_device._clockline.add_device(self)
        # now we can check

    def add_device(self, device):
        #print('Andi FPGA_Intermediatedevice: add device', device.name)
        #check if valid device and channel and if channel is already used
        #create container class and check if valid device, channel and if channel is already used
        #each channel has its own address
        device.rack, device.address, device.channel = check_device(device, AnalogOut, self.max_channels, self.child_devices, False)
        device.type = TYPE_AO
        device.addr_bits = device.address<<ADDR_SHIFT
        IntermediateDevice.add_device(self, device)
        device.set_property('address', '%i/%i/%i'%(device.rack,device.address,device.channel), 'connection_table_properties')

    def get_data(self, times, data, changes):
        "combine data bits of analog channels"
        for i,dev in enumerate(self.child_devices):
            d = np.array(dev.raw_output/10*0x7fff,np.uint32) & 0xffff #TODO: unit conversion, boundary checks, negative numbers?
            chg = np.concatenate([[d[0]!=0],((d[1:]-d[0:-1]) != 0)])
            #print('Andi combine AO',dev.name)
            if any(changes[:,dev.rack] & chg):
                raise LabscriptError("device '%s' time conflict at time(s):\n%s" % (dev.name, str(times[changes[:,dev.rack] & chg])))
            #combine data
            data[:,dev.rack+1] = data[:,dev.rack+1] | ((d|dev.addr_bits) & (chg*DATA_ADDR_MASK))
            #update changes
            changes[:,dev.rack] = changes[:,dev.rack] | chg

# PseudoclockDevice
class FPGA_board(PseudoclockDevice):
    description = 'FPGA board device class v1.0'
    allowed_children = [FPGA_PseudoClock]
    
    # TODO: to be measured.
    trigger_delay = 300e-9
    wait_day = 2e-6
    
    # call with name, IP address string and port string, output bus rate in MHz and bytes/sample
    @set_passed_properties()
    def __init__(self, name, ip_address, ip_port, bus_rate, num_racks, trigger_device=None, trigger_connection=None):
        PseudoclockDevice.__init__(self, name, trigger_device, trigger_connection)
        self.BLACS_connection = ip_address+':'+str(ip_port)
        #print('Andi init')
        self.ip_address = ip_address
        self.ip_port = str(ip_port)
        self.bus_rate = bus_rate*1e6
        self.num_racks = num_racks
        self.digits = int(np.ceil(np.log10(self.bus_rate))) # for 9e5 get 6, for 1e6 get 6, for 1.1e6 get 7
        # check allowed bytes per sample
        if (num_racks > 2): raise LabscriptError("%s: you have given %i racks but maximum 2 are allowed! use several boards instead." %(self.name, bytes_per_sample))
        elif (num_racks < 1): raise LabscriptError("%s: you have given %i racks but minimum 1 is allowed!" %(self.name, bytes_per_sample))
        if bus_rate > MAX_FPGA_RATE: raise LabscriptError("%s: maximum bus rate is %.3f MHz. You specified %.3f MHz!" %(self.name,self.MAX_FPGA_RATE,self.bus_rate))
        #TODO: should it not always be clock_resolution = 1/clock_limit ???
        self.clock_limit = self.bus_rate*2.0 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
        self.clock_resolution = 1.0/self.clock_limit

        # create Pseudoclock and clockline
        self._pseudoclock = FPGA_PseudoClock('%s_pseudoclock'%name, self, 'int_psclock')
        self._clockline = ClockLine('%s_clockline'%name, self._pseudoclock, 'int_clockline')
        #self.intermediate_device = FPGA_IntermediateDevice('%s_intermediate'%name, self._clockline,self.clock_limit)
        #print('Andi init ok')

        #save bus rate in MHz and number of racks into device properties
        self.set_property('bus_rate', self.bus_rate, 'connection_table_properties')
        self.set_property('num_racks', self.num_racks, 'connection_table_properties')

    def add_device(self, device):
        #print('Andi: FPGA_device add device:', device.name)
        if not self.child_devices and isinstance(device, Pseudoclock): #TODO: where to add secondary boards?
            PseudoclockDevice.add_device(self, device)
        elif isinstance(device, Pseudoclock):
            raise LabscriptError('You have connected %s (class %s) to %s, which is not allowed (is created internally).' % (device.name, device.__class__,self.name))
        else:
            raise LabscriptError('You have connected %s (class %s) to %s, which is not allowed.'%(device.name, device.__class__, self.name))

    def generate_code(self, hdf5_file):
        
        print('Andi: generate code')

        # Generate clock and save raw instructions to the h5 file:
        PseudoclockDevice.generate_code(self, hdf5_file)

        #get list of times in seconds
        #TODO: difference with self._pseudoclock.clock?
        #print(self._pseudoclock.clock)
        times = np.array(self._pseudoclock.times[self._clockline])
        # check overflow
        if (np.max(times)*self.bus_rate) > MAX_TIME:
            raise LabscriptError('maximum time %e s is larger allowed maximum time %e s for bus sampling rate %e Hz' % (np.max(times), MAX_TIME/self.bus_rate, self.bus_rate))
        #if (len(times) <= 100): print('times:\n', times)
                # #allocate data and list of changes
        #data contains 2-3 columns with time, data0, optional data1
        #number of rows = number of different times
        #changes is True when data0/1 has changed, otherwise False.
        data = np.zeros((len(times),self.num_racks+1),dtype=np.uint32)
        changes = np.zeros((len(times),self.num_racks),dtype=np.bool_)

        #get timestamps
        #TODO: using times*self.bus_rate)+0.5 works if initial time is integer multiple of 1/self.bus_rate.
        #      numpy.round() seems to be the better choice. but this needs further testing for different rates!
        delta = data[:, 0] = (np.array(times) * self.bus_rate).round(self.digits).astype(dtype=np.uint32)
        # check non-monotone increase in time, i.e. 0 or negative time difference.
        delta = delta[1:]-delta[0:-1]
        min_step = np.min(delta)
        if np.min(delta) < 1:
            error = delta < 1
            delta = (times[1:]-times[0:-1])[error]
            error = np.concatenate([[False],error])
            times = times[error]
            raise LabscriptError('data contains time steps smaller than %.3fns (rate %.3f MHz) at %d time (s) and delta (ns):\n%s\n%s' %
                                 (1e9/self.bus_rate, self.bus_rate/1e6, len(times), str(times), str(delta*1e9)))

        #combine data for all Intermediate devices of ClockLine
        #check conflicts = changes cannot be at the same time
        for IM in self._clockline.child_devices:
            IM.get_data(times, data, changes)

        # set NOP bit for data without action. this keeps timing but does not generate a strobe signal.
        # TODO: maybe it would be more efficient to save changes directly in data with NOP_BIT and remove changes?
        for rack in range(self.num_racks):
            data[:,rack+1] = data[:,rack+1] | (NOP_BIT_SH*np.invert(changes[:,rack]))

        # remove data where both channels do nothing except first and last sample
        # this happens for example with slow ramps with small varyation where in many samples nothing changes
        chg = changes[:,0] | changes[:,1]
        chg[0] = chg[-1] = True
        data = data[chg]

        if len(data) <= MAX_SHOW:
            if self.num_racks == 2:
                print('     time:      rack0      rack1')
                for d in data: print('%9u: 0x%08x 0x%08x' % (d[0], d[1], d[2]))
            else:
                print('     time:       data')
                for d in data: print('%9u: 0x%08x' % (d[0], d[1]))
        print('%i/%i samples, smallest time step %d x %.3f us' % (len(data), len(times), min_step, 1e6/self.bus_rate))
        print('first time %es, second time %es, last time %fs' % (data[0,0],data[1,0],data[-1,0]))

        # #save matrix to file
        group = hdf5_file['devices'].create_group(self.name)
        group.create_dataset('matrix', compression=config.compression, data=data)

        # TODO: whatfor? copied from PineBlaster. Runviewer was complaining about 'stop_time' otherwise
        #self.set_property('is_master_pseudoclock', self.is_master_pseudoclock, location='device_properties')
        self.set_property('stop_time', self.stop_time, location='device_properties')
        
        print('Andi: generate code ok')

# finds all channels of board
# device = connection object
# returns [do_list,ao_list]
# with dictionary of digital out and analog outs, key = channel name
# value = list of [ID, properties, parent name, connection to parent, last value]
def get_channels(device, is_analog):
    #get all digital and analog outputs from intermediate device
    #TODO: the properties num_AO/DO are not needed anymore
    child_list = {}
    if is_analog:
        #num_AO = device.properties['num_AO'] # AnalogChannels
        print("'%s' with %i analog outputs:" % (device.name, len(device.child_list)))
        for child_name, child in device.child_list.items():
            rack, address, channel = child.properties['address'].split('/')
            rack = int(rack)
            address = int(address)
            channel = int(channel)
            print("  '%s' %i/0x%0x/%i" % (child.name, rack, address, channel))
            #TODO: in runmanager save these properties for each channel
            props = {'base_unit':'V', 'min':-10.0, 'max':10.0,'step':0.1, 'decimals':3}
            ID = (TYPE_AO<<24)|(rack<<16)|(address<<8)|channel
            child_list[child_name] = [ID,props,child.name,child.parent_port,0.0]
    else:
        #num_DO = device.properties['num_DO'] # DigitalChannels
        print("'%s' with %i digital outputs:" % (device.name, len(device.child_list)))
        for child_name, child in device.child_list.items():
            rack, address, channel = child.properties['address'].split('/')
            rack = int(rack)
            address = int(address)
            channel = int(channel)
            print("  '%s' %i/0x%0x/%i" % (child.name, rack, address, channel))
            props = {}
            ID = (TYPE_DO<<24)|(rack<<16)|(address<<8)|channel
            child_list[child_name] = [ID,props,child.name,child.parent_port,0]
    return child_list

@runviewer_parser
class RunviewerClass(object):
    
    def __init__(self, path, device):
        self.path = path
        self.name = device.name
        self.device = device
        self.top = self.device
        self.type = None
        if device.device_class == 'FPGA_board': # pseudoclock device
            self.type = TYPE_board
            print("runviewer loading '%s' (pseudoclock)" % (device.name))
            # get pseudoclock and clockline. we expect only one of each.
            self.pseudoclock = device.child_list[list(device.child_list.keys())[0]]
            # print(pseudoclock.name)
            self.clockline = self.pseudoclock.child_list[list(self.pseudoclock.child_list.keys())[0]]
            # print(clockline.name)
            self.bus_rate = device.properties['bus_rate']
        else: # intermediate device
            # find top device
            while self.top.parent is not None:
                self.top = self.top.parent
            # get bus rate
            self.bus_rate = self.top.properties['bus_rate']
            print("Andi: top device '%s', bus rate %.3e Hz" %(self.top.name,self.bus_rate))
            if device.device_class == 'AnalogChannels':
                self.type = TYPE_AO
                print("runviewer loading '%s' (analog outputs)" % (device.name))
                self.ao_list = get_channels(device, True)
            elif device.device_class == 'DigitalChannels':
                self.type = TYPE_DO
                print("runviewer loading '%s' (digital outputs)" % (device.name))
                self.do_list = get_channels(device, False)
            else: # unknown device
                print("runviewer loading '%s' (ignore)" % (device.name))

    def get_traces(self, add_trace, clock=None):
        #print('Andi add trace', clock)
        data = []
        with h5py.File(self.path, 'r') as f: #get data sent to board
            group = f['devices/%s' % self.top.name]
            data = group['matrix'][:]
        if len(data) > 0:
            #print('Andi: matrix\n',data)
            #print('%i samples' % (len(data)))
            if self.type == TYPE_board: # main board (pseudoclock device)
                time = data[:,0]/self.bus_rate
                name = self.name + '_clockline'
                value = [(i & 1) for i in range(len(time))]
                add_trace(name, (time, value), None, None)
                return {name: (time, value)}
            elif self.type == TYPE_AO: # analog outputs (intermediate device)
                # for all channels extract from data all entries with channel device address & rack
                for name, ll in self.ao_list.items():
                    [ID, props, parent, conn, last] = ll
                    rack = (ID>>16) & 0xff
                    addr = (ID>>8) & 0xff
                    d = data[((data[:,rack+1]>>ADDR_SHIFT) & 0xff) == addr]
                    if len(d) > 0: # data available
                        if d[0,0] > 0: # TODO: initial state is not well-defined. we take now last state of channel!
                            d = np.concatenate([[np.concatenate([[0],d[-1,1:]])],d])
                        time = d[:,0]/self.bus_rate
                        value = ((d[:,rack + 1] & DATA_MASK)/0x7fff)*10.0 # TODO: convertion into volts or any other unit
                        if time[-1] != (data[-1,0]/self.bus_rate): # extend trace to last time
                            time = np.concatenate([time,[data[-1,0]/self.bus_rate]])
                            value = np.concatenate([value, [value[-1]]])
                        #print("ao '%s' 0x%x:" % (name,ID))
                        #print('time = ',time)
                        #print('data = ',value)
                    else: # address is not used. assume channel is at 0.0
                        time = np.array([data[0, 0], data[-1, 0]]) / self.bus_rate
                        value = np.array([0.0, 0.0])
                    # we add trace for all channels, even if not used
                    add_trace(name, (time, value), parent, conn)
            elif self.type == TYPE_DO: # digital outputs (intermediate device)
                # for all channels extract from data all entries with channel device address & rack
                for name, ll in self.do_list.items():
                    [ID, props, parent, conn, last] = ll
                    rack = (ID>>16) & 0xff
                    addr = (ID>>8) & 0xff
                    channel = ID & 0xff
                    d = data[((data[:,rack+1]>>ADDR_SHIFT) & 0xff) == addr]
                    if len(d) > 0: # address is used - find where channel changes
                        if d[0,0] > 0: # TODO: initial state is not well-defined. we take now last state of channel!
                            d = np.concatenate([[np.concatenate([[0],d[-1,1:]])],d])
                        bit = (d[:,rack+1] >> channel) & 1
                        chg = np.concatenate([[True],((bit[1:]-bit[0:-1]) != 0)])
                        time = d[:,0][chg]/self.bus_rate
                        value = bit[chg]
                        if time[-1] != (data[-1,0]/self.bus_rate): # extend trace to last time
                            time = np.concatenate([time,[data[-1,0]/self.bus_rate]])
                            value = np.concatenate([value, [value[-1]]])
                        #print("do '%s' 0x%x:" % (name,ID))
                        #print('time = ',time)
                        #print('data = ',value)
                    else: # address is not used. assume channel is 0
                        time = np.array([data[0, 0], data[-1, 0]]) / self.bus_rate
                        value = np.array([0, 0])
                    # we add trace for all channels, even if not used
                    add_trace(name, (time, value), parent, conn)
            else: # DDS not implemented
                pass
        #TODO: not sure which name to use and what data it wants here?
        return {}
        
from blacs.tab_base_classes import Worker, define_state
from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
from blacs.device_base_class import DeviceTab

#connect to server
#timeout = time in seconds (float) after which function returns with error
#returns connected socket if connected, None on error
def connect(timeout, con):
    ip, port = con.split(':')
    port = int(port)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    print("connecting to %s:%i (max %.3fs) ..." % (ip, port, timeout))
    try:
        sock.connect((ip,port))
        #sock.setblocking(0)
        sock.settimeout(None)
        print("connection ok")
        return sock
    except socket.timeout:
        print("timeout!")
    except Exception as e:
        print("exception: \"%s\" (ignore)" % (str(e)))
    sock.close()
    return None

#receive data from server while sending data (can be None)
#function returns when recv_bytes received or timeout (None=Infinite)
#returns received bytes from server or None if nothing received (timeout)
#        if recv_bytes = 0 returns True if data was sent, otherwise None
#if output is not None:
#   if recv_bytes == 0 prints 'output' + number of sent bytes
#   if recv_bytes == 2 prints 'output' + information if ACK/NACK received
#   if recv_bytes > 2  prints 'output' + number of received bytes
def send_recv_data(sock, data, timeout, recv_bytes=2, output=None):
    size = None
    if (data is None) and (recv_bytes > 0):
        #wait for new data
        (rd, wr, err) = select.select([sock], [], [], timeout)
    else:
        #send data
        sock.send(data)
        if recv_bytes > 0: #wait until data received
            (rd, wr, err) = select.select([sock], [], [], timeout)
        else: # only send data
            # here we wait until sending finished. if this fails we get timeout warning below.
            (rd, wr, err) = select.select([], [sock], [], timeout)
            if len(wr) == 1: # data sent (at least is in output buffer).
                if output is not None:
                    print('%s %d bytes sent' % (output,len(data)))
                return True
    if len(rd) == 1: #data available for receive
        data = sock.recv(recv_bytes)
        #print("received %s (%d bytes)" % (str(data), len(data)))
        if output is not None: # output what we received
            if recv_bytes == 2: # expect ACK or NACK
                if data == SERVER_ACK: print('%s ACK' % (output))
                elif data == SERVER_NACK: print('%s NACK' % (output))
                elif len(data) == 0: print('%s closed connection!' % (output))
                else: print('%s unknown bytes %s' % (output, data))
            else: # expect other data
                print('%s received %d bytes' % (output, len(data)))
        return data
    if output is not None: print('%s failed (timeout)!' % (output))
    return None

def init_connection(device_name, con):
    "connect - open - reset - config. returns socket or None on error"
    sock = connect(SOCK_TIMEOUT, con)
    if sock is None: print("'%s' connection %s failed!" % (device_name, con))
    else:
        print("'%s' connected at %s ok" % (device_name, con))
        # open board
        result = send_recv_data(sock, SERVER_OPEN, SOCK_TIMEOUT, output='OPEN')
        if result == SERVER_ACK:
            # reset board
            result = send_recv_data(sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
            if result == SERVER_ACK:
                # send configuration. server will return new configuration (no ACK)
                data = to_config(SERVER_CONFIG,CONFIG_CLOCK,CONFIG_SCAN,CONFIG_CTRL,CONFIG_EXTRIG,CONFIG_REPS,CONFIG_TRANS)
                result = send_recv_data(sock, data, SOCK_TIMEOUT, recv_bytes=len(data), output='CONFIG')
                if result is not None: 
                    [cmd, clock, scan, config, extrig, reps, trans] = from_config(result)
                    if cmd != SERVER_CONFIG: print('config received (%s) instead of SERVER_CONFIG!' % (str(cmd)))
                    else:
                        print("'%s' ready!" % (device_name))
                        return sock
        #something went wrong. close socket after short timeout
        send_recv_data(sock, SERVER_CLOSE, 0.1, output='close')
        sock.close()
    return None

def send_data(sock, data, bus_rate):
    "send data to socket. returns True if ok otherwise error"
    if sock is not None:
        if len(data) <= MAX_SHOW:
            times = data[:,0]/bus_rate
            if len(data) > 1: min_step = np.min(times[1:]-times[0:-1])
            else:             min_step = 0
            if len(data[0]) == 3:
                print('     time:      rack0      rack1')
                for d in data: print('%9u: 0x%08x 0x%08x' % (d[0], d[1], d[2]))
            else:
                print('     time:       data')
                for d in data: print('%9u: 0x%08x' % (d[0], d[1]))
            print('%i samples, smallest time step %.3es, rate %.3f MHz' % (len(data), min_step, bus_rate*1e-6))
            if len(data) > 1: print('first time %fs, second time %es, last time %fs' % (times[0],times[1],times[-1]))
        else:
            print('%i samples' % (len(data)))
        # reset board
        result = send_recv_data(sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
        if result == SERVER_ACK:
            # send configuration. server will return new configuration (no ACK)
            config = to_config(SERVER_CONFIG,CONFIG_CLOCK,CONFIG_SCAN,CONFIG_CTRL,CONFIG_EXTRIG,CONFIG_REPS,CONFIG_TRANS)
            result = send_recv_data(sock, config, SOCK_TIMEOUT, recv_bytes=len(config), output='CONFIG')
            if result is not None:
                [cmd, clock, scan, config, extrig, reps, trans] = from_config(result)
                if cmd != SERVER_CONFIG: print('config received (%s) instead of SERVER_CONFIG!' % (str(cmd)))
                else:
                    # write to device
                    num_bytes = len(data)*len(data[0])*4
                    result = send_recv_data(sock, to_client_data32(SERVER_WRITE, num_bytes), SOCK_TIMEOUT, output='SEND %d bytes?'%(num_bytes))
                    if result == SERVER_ACK:
                        result = send_recv_data(sock, data.tobytes(order='C'), None, output='SEND %d bytes'%(num_bytes))
                        if result == SERVER_ACK:
                            print('Andi %d bytes sent to server!' % (num_bytes))
                            return True
    return False

@BLACS_tab
class FPGA_Tab(DeviceTab):
    def initialise_GUI(self):
        device = self.settings['connection_table'].find_by_name(self.device_name)
        self.con = device.BLACS_connection
        self.num_racks = device.properties['num_racks']
        self.bus_rate = device.properties['bus_rate']
        print("'%s' init devices" % (self.device_name))

        # get pseudoclock and clockline. we expect only one of each.
        self.pseudoclock = device.child_list[list(device.child_list.keys())[0]]
        # print(pseudoclock.name)
        self.clockline = self.pseudoclock.child_list[list(self.pseudoclock.child_list.keys())[0]]
        # print(clockline.name)

        #get all channels from intermediate devices
        #TODO: there is a '-' below name. it seems the name should be 'channel #' and the '-' should be device.name?
        #      see blacs/device_base_class.py "What do the properties dictionaries need to look like?" but I cannot get this working.
        ao_list = {}
        do_list = {}
        for IM_name, IM in self.clockline.child_list.items():
            if IM.device_class == 'AnalogChannels':
                ao_list.update(get_channels(IM, True))
            elif IM.device_class == 'DigitalChannels':
                do_list.update(get_channels(IM, False))
            else: # DDS not implemented yet
                print("'%s' unknown device (ignore)" % IM_name)

        # get ananlog output properties
        ao_prop = {}
        for name, ll in ao_list.items():
            [ID, props, parent, conn, last] = ll
            ao_prop[name] = props
        #get digital output properties (emptry)
        do_prop = {}
        for name, ll in do_list.items():
            [ID, props, parent, conn, last] = ll
            do_prop[name] = props

        # Create the output objects
        print('Andi create %i analog  outputs' % (len(ao_list)))
        self.create_analog_outputs(ao_prop)
        print('Andi create %i digital outputs' % (len(do_list)))
        self.create_digital_outputs(do_prop)

        # create widgets and place on GUI
        dds_widget, ao_widgets, do_widgets = self.auto_create_widgets()
        self.auto_place_widgets(('Analog outputs', ao_widgets), ('Digital outputs', do_widgets))

        # Create and set the primary worker
        self.create_worker("main_worker", FPGA_Worker, {'con':self.con,'do_list':do_list,'ao_list':ao_list,'num_racks':self.num_racks,'bus_rate':self.bus_rate})
        self.primary_worker = "main_worker"

        # Set the capabilities of this device
        self.supports_remote_value_check(False)
        self.supports_smart_programming(False)

    @define_state(MODE_BUFFERED, True)
    def start_run(self, notify_queue):
        print('Andi BLACS start_run')
        success = yield(self.queue_work(self.primary_worker, 'start_run'))
        if success:
            self.statemachine_timeout_add(100, self.status_monitor, notify_queue)
        else:
            raise RuntimeError('Failed to start run')
    
    @define_state(MODE_BUFFERED, True)
    def status_monitor(self, notify_queue):
        print('Andi BLACS status_monitor')
        finished = yield(self.queue_work(self.primary_worker, 'status_monitor'))
        if finished:
            notify_queue.put('done')
            self.statemachine_timeout_remove(self.status_monitor)
                        
#BLACS worker thread
class FPGA_Worker(Worker):
    def init(self):
        exec('from numpy import *', globals())
        global h5py; import labscript_utils.h5_lock, h5py
        global re; import re
        global socket; import socket
        global select; import select
        global struct; import struct

        print("'%s' init" % (self.device_name))

        # change ananlog output list to contain only IDs and last values
        for name, ll in self.ao_list.items():
            [ID, props, parent, conn, last] = ll
            self.ao_list[name] = [ID, last]
        # change digital output list to contain only IDs and last values
        for name, ll in self.do_list.items():
            [ID, props, parent, conn, last] = ll
            self.do_list[name] = [ID, last]

        # connect - open - reset - configure board
        # on error: we disconnect and set self.sock=None
        #           in program_manual and transition_to_buffered we retry
        self.sock = init_connection(self.device_name, self.con)
        self.first_time = True

    def program_manual(self, front_panel_values):
        if self.sock == None: # try to reconnect to device
            self.sock = init_connection(self.device_name, self.con)
        #if self.sock is not None: ignore for testing
        if True:
            #print("'%s' program manual" % (self.device_name))
            # TODO: is there a more efficient way? 
            #print(front_panel_values)
            # we first loop through all GUI devices and generate a list of changed digital channels
            # and for changed analog channels we can already generate samples since have unique addresses
            data = []
            time = 0
            sample = [time] + [NOP_BIT_SH]*self.num_racks
            do_IDs = []
            for key, value in front_panel_values.items():
                try:
                    [ID, last] = self.do_list[key] # DigitalChannels
                    if self.first_time or (value != last):
                        print("'%s' changed from %i to %i" % (key, last, value))
                        do_IDs = do_IDs + [ID] # save changed ID
                        self.do_list[key] = [ID, value] # save new state
                except KeyError:
                    try:
                        [ID, last] = self.ao_list[key] # AnalogChannels
                        if self.first_time or (value != last):
                            print("'%s' changed from %f to %f" % (key, last, value))
                            rack = (ID>>16) & 0xff
                            address = (ID>>8) & 0xff
                            sample[rack+1] = (address<<ADDR_SHIFT)|((int((value*0x7fff) + 0.5)//10) & 0xffff)
                            data.append(sample)
                            time += 1
                            sample = [time] + [NOP_BIT_SH]*self.num_racks
                            self.ao_list[key] = [ID, value]
                    except KeyError: # unknown device?
                        pass
            # generate samples for changed digital channels
            # for each address & rack we have to collect all channel bits
            if len(do_IDs) > 0:
                do_IDs = list(set(do_IDs)) # gives unique IDs
                print(do_IDs)
                for ID in do_IDs:
                    rack = (ID>>16) & 0xff
                    address = (ID>>8) & 0xff
                    sample[rack+1] = (address<<ADDR_SHIFT)
                    for key in self.do_list: # get all bits from all channels with same rack & address
                        cID, last = self.do_list[key]
                        if ((cID & 0xffff00) == (ID & 0xffff00)) :
                            channel = cID & 0xff
                            sample[rack+1] = sample[rack+1] | (last << channel) # add bit
                    data.append(sample) # save sample
                    time += 1
                    sample = [time] + [NOP_BIT_SH]*self.num_racks
            # next time update only changes
            self.first_time = False
            # write samples to device
            if len(data) > 0:
                if send_data(self.sock, np.array(data,dtype=np.uint32),self.bus_rate) == True:
                    # start output
                    result = send_recv_data(self.sock, to_client_data32(SERVER_START, 1), SOCK_TIMEOUT, output='START')
                    if result == SERVER_ACK:
                        # wait for completion (should be immediately)
                        # TODO: maybe use IRQ
                        while True:
                            result = send_recv_data(self.sock, SERVER_STATUS, SOCK_TIMEOUT, output='STATUS', recv_bytes=14)
                            if result is None: break
                            else:
                                [cmd, status, time, samples] = from_client_status(result)
                                if cmd == SERVER_STATUS_RSP:
                                    if status & STATUS_RUN: # running state
                                        print('running  time %8i samples %8i' % (time, samples))
                                    elif status & STATUS_END: # end state
                                        print('finished time %8i samples %8i' % (time, samples))
                                        result = SERVER_ACK # all ok
                                        break
                                    elif status & STATUS_ERROR: # error state
                                        print('error    time %8i samples %8i status 0x%8x error!' % (time, samples, status))
                                        break
                                    else: # unexpected state
                                        print('stopped  time %8i samples %8i status 0x%8x unexpected?' % (time, samples, status))
                                        break
                        # stop output
                        send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
                        if result == SERVER_ACK:
                            return front_panel_values # ok
        return None # TODO: how to indicate error?

    def transition_to_buffered(self, device_name, h5file, initial_values, fresh):
        if self.sock == None: # try to reconnect to device
            self.sock = init_connection(self.device_name, self.con)
        if self.sock is not None:
            with h5py.File(h5file,'r') as hdf5_file:
                group = hdf5_file['devices/%s'%device_name]
                data = group['matrix'][:]
                # send data
                if send_data(self.sock, data, self.bus_rate) == True:
                    pass
            #TODO: return final values
            return {}
        return None # calls abort_transition_to_buffered() and sets device is pause state
                 
    def abort_transition_to_buffered(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            # reset board
            result = send_recv_data(self.sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
            if result == SERVER_ACK:
                return True # success
        return True # return True even on error, otherwise get ugly stack trace
    
    def abort_buffered(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            # stop board
            #result = send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_NOW), SOCK_TIMEOUT, output='stop')
            result = send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
            if result == SERVER_ACK:
                # reset board
                result = send_recv_data(self.sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
                if result == SERVER_ACK:
                    return True # success
        return False # error
     
    def transition_to_manual(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            # stop board
            #result = send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_AT_END), SOCK_TIMEOUT, output='stop')
            result = send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
            if result == SERVER_ACK:
                return True
        return False # error
             
    def start_run(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            repetitions = 1 # number of repetitions. 0=infinite. 1=default. requires restart bit to be set in control bits (not fully tested)
            result = send_recv_data(self.sock, to_client_data32(SERVER_START, repetitions), SOCK_TIMEOUT, output='START')
            if result == SERVER_ACK:
                return True
        return False # error
    
    def status_monitor(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            result = send_recv_data(self.sock, SERVER_STATUS, SOCK_TIMEOUT, output=None, recv_bytes=14)
            if result is not None:
                [cmd, status, time, samples] = from_client_status(result)
                if cmd == SERVER_STATUS_RSP:
                    if status & STATUS_RUN: # running state
                        print('running  time %8i samples %8i' % (time, samples))
                        return False
                    elif status & STATUS_END: # end state
                        print('finished time %8i samples %8i' % (time, samples))
                        return True
                    elif status & STATUS_ERROR: # error state
                        print('error    time %8i samples %8i status 0x%8x error!' % (time, samples, status))
                        return True
                    else: # unexpected state
                        print('stopped  time %8i samples %8i status 0x%8x unexpected?' % (time, samples, status))
                        return None
        return None # TODO: how to indicate error?

    def shutdown(self):
        if self.sock is not None:
            # TODO: is transition_to_manual called before? to be sure we stop board.
            # stop board
            #send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_NOW), SOCK_TIMEOUT)
            send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT)
            # close connection
            data = send_recv_data(self.sock, SERVER_CLOSE, SOCK_TIMEOUT)
            self.sock.close()
            self.sock = None
        print('Andi worker shutdown')