# FPGA-SoC_experiment_control

This project contains hopefully everything to generate your own FPGA-SoC experimental control system designed for cold or ultracold atoms experiments. But any other use is welcome!

The heart of the exerpimental control system is the Cora-Z7 board from Digilent Inc. https://store.digilentinc.com/cora-z7-zynq-7000-single-core-and-dual-core-options-for-arm-fpga-soc-development/. There are two boards available: Cora-Z7-10 and Cora-Z7-07S where the former has a dual-core CPU and the later a single-core CPU and a slightly smaller FPGA. The only measured difference between the performance of the two boards is that the uploading rate of the single-core CPU board was about 80% smaller than that of the dual-core CPU. The FPGA and DMA performance is exactly the same. The single-core board is slightly cheaper and the difference in FPGA size is not much. If you do not plan big additions in the FPGA part (we use about 60-80%) and you never upload many many samples, then this board is perfectly fine.

This is a low-cost FPGA-SoC development board. The SoC (system-on-a-chip) has a dual or single-core CPU (ARM Cortex A9) and on the same chip a FPGA (field-programmable gate array). The CPU allows to run a simple Linux operating system (Petalinux 2017.4) on the CPU which allows you to run your custom code or applications and facilitates using system services to access external hardware (Ethernet, DDR memory, USB keyboard/mouse, SD card, etc.). The FPGA allows to implement custom hardware (logic, PLLs, SERDES, etc.) which you can configure as you please. The tight connection between the CPU and FPGA allows to control the hardware by software and to efficiently transfer data between the two parts. 

The implementation of the FPGA-SoC for "experimental control" was born out of the need to replace an old DIO64 card (from Viewpoint Systems) which is not anymore supported/sold and uses old Hardware (PCI slot) and old operating systems (Windows XP/7/8). This card was preferrably programmed with NI Labview/LabwindowsCVI usser application programms which create a table of time and instructions (32bit time and 32bit instruction/data in the simplest case) which is sent to the driver and is then executed on the card. This card outputs the instructions at the programmed time (typically in units of us) on a 50-way ribbon cable of 2-3m length. This cable is connected to a 19" rack with our custom hardware. After buffering and electrical isolation (in a buffer card) the instructions/data are on the backplane of the rack on a bus. Several plug-in modules of different type and size can be inserted into the rack and connect to this bus. Typical devices are digital and analog outpus and DDS (direct digital synthesizers, i.e. RF generators). Some experiments might use also input devices, but we do not have. Each device has an address decoder and 7 bits of the data are reserved for the address of the device. 16 data bits are reserved for device specific data. One bit called "Strobe" is used as a pseudo-clock, which is simply a clock which pulses only when something on the bus should be updated. This signal is originally recovered from a bit generated by the software and sent with the data by the DIO64 card. This bit must change state for every instruction and in the buffer card a simple electronic cirquit generates the pulses out of this signal. The pulses must be shorter than the update rate of the bus (essentially, it has twice the frequency than the bus) and must be delayed in time with the bus update. This way delays between different bits on the bus and noise is cancelled.

The FPGA-SoC replaces the DIO64 card but also improves the old system in many ways:
1. the data is uploaded via Gigabit Ethernet:
  * even for long sequences the uploading time is small (2.3s for 10M samples)
  * electrical isolation given by Ethernet
  * much longer cables are possible. this even allows remote-control over network.
  * no driver is needed on the experimental control computer 
    * no restrictions on operating system
    * no restriction on used software
  * experimental control computer is free to do other things during the execution of the sequence since there is no busy driver running in background
2. 10M samples can be stored directly on the board
  * this size (128MB) is more than sufficient for most of our experiments
  * repetitions of the same experiment can be done directly by the board without uploading again the data
  * in a future possible extension only parts of the data could be updated in memory
3. contiguous bus output rate of 30-40MHz
  * the data from the memory into the FPGA part is transmitted via direct memory access (DMA) which gives the limitation of contiguous data output rate
  * write to the bus and read from the bus (not in our experiment) can be done simultaneously without affecting the other channel
  * using more of the unused DMA ports can increase the rate (factor 2 should be possible, maybe 100MHz?)
4. the internal FIFOs hold 8192 samples which allows short "burst" of output/input at higher rates
  * for short time and ensuring the FIFO is not getting empty/full output/input can be done at higher rates
5. the internal clock of the FPGA part is running at the moment with 50MHz
  * increasing to 100MHz is "easy" but you most likely, the FPGA design has to be adapted.
  * going to 200MHz might be possible but will be come more difficult. 250MHz is the limit.
  * using the "strobe" the output rate is limited to half of the FPGA clock frequency (current design even 1/3) but this could be changed
  * additional considerations are voltage levels (at the moment 5V) and proper termination of the bus (at the moment unterminated). 
  * to use differential lines the FPGA would support this but the given board design strongly constrains on usable pairs. Additionally, levels cannot be easily mixed (should work but nobody will warrant for this). 
6. the FPGA-SoC allows to customize for our application. We have the freedom to implement new ideas, features, use new devices, implement protocols, etc. here a list what could be done or is partially already done or tested:
  * we tested to synchronize several boards by using a common clock signal and to trigger the boards from one board and measure and correct for the propagation delay of the trigger signal. This way we could synchronize 2 boards with about 1ns. This is not fully implemented but should become a standard feature.
  * you could run additional software on the CPU. for example some python analysis/feedback program, which changes the state of the experiment depending on measured values. note however, this cannot be "very" fast (the CPU runs at 650MHz). Very fast things could be done on the hardware, but also this is limited to 100-200MHz, but things can be done in parallel (on many bits).
  * the board features an USB port which can be configured as device (passive, like a flash drive) or host (active, like your computer). Many modern laboratory equipments allow to remote control via USB (using the USBTMC protocol) or older devices use the GPIB port for which USB-to-GPIB adapters exist. You could directly control such a device from the FPGA-SoC using a simple application running on the CPU or with data which you send via Ethernet.
  * one could implement ramps directly on the board and update only parts of the sequence

The project has several folders. Look at the readme.md files there for specific instructions.

1. FPGA-SoC-Cora-Z7-10: this is the firmware to be uploaded on the Cora-Z7-10 board
  a. Vivado: this contains the Vivado Project on which you generate the logic part of the board
  b. Petalinux: this contains the Petalinux-Project on which you generate the linux boot image and boot loader 
2. FPGA-SoC-Cora-Z7-07S: this is the firmware to be uploaded on the Cora-Z7-07S board
  a. Vivado: this contains the Vivado Project on which you generate the logic part of the board
  b. Petalinux: this contains the Petalinux-Project on which you generate the linux boot image and boot loader 
3. buffer-card: schematics, Gerber files and bill of materials needed for the buffer card
4. auto-synchronization: schematics of the auto-synchronization electronics
5. labscript: labscript device implementation



